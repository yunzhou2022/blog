---
tags: [前端, react-router-dom]
date: 26.1.19
---

# react-router-dom 路由

react-router-dom 路由提供四种模式的路由

- BrowserRouter
- StaticRouter
- HashRouter
- MemoryRouter

## BrowserRouter

底层使用浏览器的 History API（如 `pushState`/`replaceState`），实现前端路由跳转。URL 变化时页面不会刷新，适合现代 web 应用，要求后端服务器将所有路由请求重定向到 `index.html`。

### 使用示例

```jsx
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">首页</Link>
        <Link to="/about">关于</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </BrowserRouter>
  );
}

function Home() {
  return <div>首页内容</div>;
}
function About() {
  return <div>关于页面</div>;
}
```

### 简版源码

```js
// Link
function Link({ to, children }) {
  return <a href={to}>{children}</a>;
}

// BrowserRouter
import { useState, useEffect } from "react";
const RouterContext = React.createContext();

function BrowserRouter({ children }) {
  const [location, setLocation] = useState(window.location.pathname);

  useEffect(() => {
    const onPopState = () => setLocation(window.location.pathname);
    window.addEventListener("popstate", onPopState);
    return () => window.removeEventListener("popstate", onPopState);
  }, []);

  const navigate = (to) => {
    window.history.pushState({}, "", to);
    setLocation(to);
  };

  return (
    <RouterContext.Provider value={{ location, navigate }}>
      {children}
    </RouterContext.Provider>
  );
}

// Routes
function Routes({ children }) {
  const { location } = React.useContext(RouterContext);
  let element;
  React.Children.forEach(children, (child) => {
    if (!element && child.props.path === location) {
      element = child;
    }
  });
  return element ? element.props.element : null;
}

// Route
function Route() {
  return null; // 只做匹配，不渲染
}
```

---

## HashRouter

依赖于 URL 的哈希（`#`）部分管理路由。优点在于无需后端配置，兼容性好，浏览器刷新不会丢失路由。URL 会以 `/#/路径` 的形式出现。

### 使用示例

```jsx
import { HashRouter, Routes, Route, Link } from "react-router-dom";

function App() {
  return (
    <HashRouter>
      <nav>
        <Link to="/">首页</Link>
        <Link to="/about">关于</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </HashRouter>
  );
}
```

适合静态文件托管或后端无法配置路由回退的场景。

### 简单源码实现

#### Link

```jsx
function Link({ to, children }) {
  const { navigate } = React.useContext(RouterContext);

  const handleClick = (e) => {
    e.preventDefault();
    navigate(to);
  };

  return (
    <a href={`#${to}`} onClick={handleClick}>
      {children}
    </a>
  );
}
```

#### HashRouter

```jsx
const RouterContext = React.createContext();

function HashRouter({ children }) {
  const [location, setLocation] = React.useState(
    () => window.location.hash.replace(/^#/, "") || "/"
  );

  React.useEffect(() => {
    const onHashChange = () => {
      setLocation(window.location.hash.replace(/^#/, "") || "/");
    };
    window.addEventListener("hashchange", onHashChange);
    return () => window.removeEventListener("hashchange", onHashChange);
  }, []);

  const navigate = (to) => {
    if (window.location.hash.replace(/^#/, "") !== to) {
      window.location.hash = to;
    }
    setLocation(to);
  };

  return (
    <RouterContext.Provider value={{ location, navigate }}>
      {children}
    </RouterContext.Provider>
  );
}
```

#### Routes

```jsx
function Routes({ children }) {
  const { location } = React.useContext(RouterContext);
  let element = null;
  React.Children.forEach(children, (child) => {
    if (!element && child.props.path === location) {
      element = child;
    }
  });
  return element ? element.props.element : null;
}
```

#### Route

```jsx
function Route() {
  return null;
}
```


---

## MemoryRouter

将路由状态保存在内存中，不会对地址栏产生任何影响。常用于测试环境、非浏览器环境（如 React Native）、嵌入式场景（如对话框、组件库 demo 等）。

### 使用示例

```jsx
import { MemoryRouter, Routes, Route } from "react-router-dom";

function App() {
  return (
    <MemoryRouter initialEntries={["/"]}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </MemoryRouter>
  );
}
```

初始路径可通过 `initialEntries` 指定。

### 简单源码实现

```jsx
// 一个最简 MemoryRouter 实现示例：

const RouterContext = React.createContext();

function MemoryRouter({ initialEntries = ['/'], children }) {
  const [history, setHistory] = React.useState(initialEntries);
  const [index, setIndex] = React.useState(0);

  const location = history[index];

  const navigate = React.useCallback((to, options = {}) => {
    if (options.replace) {
      setHistory(hist => {
        const newHist = [...hist];
        newHist[index] = to;
        return newHist;
      });
    } else {
      const nextHistory = history.slice(0, index + 1).concat(to);
      setHistory(nextHistory);
      setIndex(nextHistory.length - 1);
    }
  }, [history, index]);

  const value = React.useMemo(() => ({
    location,
    navigate,
  }), [location, navigate]);

  return (
    <RouterContext.Provider value={value}>
      {children}
    </RouterContext.Provider>
  );
}
```

---

## StaticRouter

用于服务端渲染（SSR），不会改变 location，只根据传入的 location 渲染路由结果。通常不会在浏览器端使用。

### 使用示例

```jsx
import { StaticRouter } from "react-router-dom/server";
import { Routes, Route } from "react-router-dom";

function App({ location, context }) {
  return (
    <StaticRouter location={location} context={context}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </StaticRouter>
  );
}
```

适用于 Node.js 服务端渲染场景。

### 简单源码实现

#### StaticRouter

```jsx
const RouterContext = React.createContext();

function StaticRouter({ location, context = {}, children }) {
  // StaticRouter 用于 SSR，location 由服务器传入，不会改变
  // context 用于在 SSR 过程中传递数据（如重定向信息）
  
  const navigate = (to, options = {}) => {
    // 在 SSR 中，navigate 主要用于记录重定向
    if (options.replace) {
      context.action = "REPLACE";
    } else {
      context.action = "PUSH";
    }
    context.url = to;
  };

  const value = React.useMemo(() => ({
    location,
    navigate,
  }), [location]);

  return (
    <RouterContext.Provider value={value}>
      {children}
    </RouterContext.Provider>
  );
}
```

#### Link

```jsx
function Link({ to, children }) {
  const { navigate } = React.useContext(RouterContext);

  const handleClick = (e) => {
    e.preventDefault();
    navigate(to);
  };

  return (
    <a href={to} onClick={handleClick}>
      {children}
    </a>
  );
}
```

#### Routes

```jsx
function Routes({ children }) {
  const { location } = React.useContext(RouterContext);
  let element = null;
  React.Children.forEach(children, (child) => {
    if (!element && child.props.path === location) {
      element = child;
    }
  });
  return element ? element.props.element : null;
}
```

#### Route

```jsx
function Route() {
  return null; // 只做匹配，不渲染
}
```

#### Context 的消费

在 SSR 场景中，`context` 对象在服务端渲染完成后，由服务器代码消费，主要用于处理重定向等场景：

```jsx
// 服务端代码示例
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom/server';

function handleRequest(req, res) {
  const context = {}; // 创建空的 context 对象
  
  const html = renderToString(
    <StaticRouter location={req.url} context={context}>
      <App />
    </StaticRouter>
  );
  
  // 消费 context：检查是否有重定向
  if (context.url) {
    // 如果组件中调用了 navigate，context.url 会被设置
    res.redirect(302, context.url);
    return;
  }
  
  // 正常渲染 HTML
  res.send(`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${html}</div>
      </body>
    </html>
  `);
}
```

**关键点：**
- `location` 由服务器传入，不会动态变化（静态）
- `context` 用于在 SSR 过程中传递信息（如重定向 URL）
- 不监听浏览器事件（服务端无浏览器环境）
- `navigate` 主要用于记录重定向信息到 context 中
- **Context 消费**：服务端在渲染完成后检查 `context.url`，如果有值则执行重定向

# 总结

- BrowserRouter

监听浏览器 popstate 变化， 提供 location和navigate方法

- HashRouter

监听浏览器的 hash 变化， 提供 location 和navigate方法

- MemoryHistory

自己维护一套路由栈，提供 locaiton 和navigate方法

- StaticRouter

不做啥事情，透传 server 提供的 location 