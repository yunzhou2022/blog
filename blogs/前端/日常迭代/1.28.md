---
tags: [前端, xstate]
date: 26.1.28
---

# xsate

## what

XState 是 JavaScript/TypeScript 的状态机 / 状态图库，用于管理复杂的状态逻辑，解决「状态混乱、条件分支臃肿、边边角角的状态切换漏处理」问题，核心概念：

- 状态（states）：事物的离散状态（如idle/loading/success/error）
- 事件（events）：触发状态切换的信号（如FETCH/SUCCESS/ERROR/RETRY）
- 过渡（transitions）：事件触发后从一个状态到另一个状态的切换
- 上下文（context）：状态机的「数据仓库」，存储状态相关的变量
- 动作（actions）：状态切换 / 进入 / 退出时执行的副作用（如请求数据、更新 DOM）
- 守卫（guards）：条件判断，决定是否执行某个过渡


## how to use

### 基础使用

```js
import { createMachine, interpret } from 'xstate';

// 1. 创建状态机：定义状态、事件、过渡规则
const fetchMachine = createMachine({
  /**
   * initial：初始状态
   * id：状态机唯一标识（可选，复杂场景推荐）
   * states：所有状态的集合
   */
  id: 'fetch',
  initial: 'idle', // 初始为「空闲」状态
  states: {
    idle: {
      // 空闲状态下，接收FETCH事件，切换到loading状态
      on: { FETCH: 'loading' }
    },
    loading: {
      // 加载状态下，接收SUCCESS→success状态，接收ERROR→error状态
      on: {
        SUCCESS: 'success',
        ERROR: 'error'
      }
    },
    success: {
      // 成功状态下，接收RESET→回到空闲状态
      on: { RESET: 'idle' }
    },
    error: {
      // 失败状态下，接收RETRY→重新加载，接收RESET→回到空闲
      on: {
        RETRY: 'loading',
        RESET: 'idle'
      }
    }
  }
});

// 2. 解释器（interpret）：让状态机「活起来」，处理事件、触发状态变化
const fetchService = interpret(fetchMachine);

// 3. 订阅状态变化：监听状态机的状态更新，执行副作用（如更新UI、打印日志）
fetchService.subscribe((state) => {
  console.log('当前状态：', state.value); // state.value 是当前的状态值（如idle/loading）
});

// 4. 启动状态机
fetchService.start();

// 5. 发送事件：触发状态切换（模拟实际业务中的操作，如点击「请求」按钮）
fetchService.send({ type: 'FETCH' }); // 空闲 → 加载
fetchService.send({ type: 'SUCCESS' }); // 加载 → 成功
fetchService.send({ type: 'RESET' }); // 成功 → 空闲
fetchService.send({ type: 'FETCH' }); // 空闲 → 加载
fetchService.send({ type: 'ERROR' }); // 加载 → 失败
fetchService.send({ type: 'RETRY' }); // 失败 → 加载

// 6. 停止状态机（组件卸载/页面关闭时执行，防止内存泄漏）
// fetchService.stop();
```

### 带上下文，action，入口

```js
import { createMachine, interpret, assign } from 'xstate';

// 模拟接口请求的异步函数
const fetchData = async (id) => {
  await new Promise((resolve, reject) => {
    setTimeout(() => {
      // 模拟随机成功/失败
      Math.random() > 0.5 
        ? resolve({ id, data: '请求成功的返回数据' }) 
        : reject(new Error('网络异常，请求失败'));
    }, 1000);
  });
};

// 进阶状态机：带上下文、动作、assign、入口动作
const advancedFetchMachine = createMachine({
  id: 'advancedFetch',
  initial: 'idle',
  /**
   * context：状态机的「数据仓库」，初始值是一个对象
   * 存储：请求ID、返回数据、错误信息
   */
  context: {
    fetchId: null,
    data: null,
    error: null
  },
  states: {
    idle: {
      on: {
        // FETCH事件：携带参数（如fetchId），切换到loading
        FETCH: {
          target: 'loading',
          // assign：修改上下文（纯函数，接收context和event，返回新的context）
          actions: assign((context, event) => ({
            fetchId: event.fetchId, // 从事件中获取fetchId，更新到上下文
            data: null, // 重置数据
            error: null // 重置错误
          }))
        }
      }
    },
    loading: {
      /**
       * entry：进入该状态时立即执行的动作（数组形式，可多个动作）
       * invoke：调用异步函数（XState推荐的异步处理方式，替代手动Promise）
       */
      invoke: {
        // src：异步函数，接收context和event，返回Promise
        src: (context) => fetchData(context.fetchId),
        // onDone：异步执行成功时，触发的事件（携带结果data）
        onDone: {
          target: 'success',
          actions: assign((_, event) => ({
            data: event.data // 将异步结果更新到上下文
          }))
        },
        // onError：异步执行失败时，触发的事件（携带错误error）
        onError: {
          target: 'error',
          actions: assign((_, event) => ({
            error: event.error.message // 将错误信息更新到上下文
          }))
        }
      }
    },
    success: {
      // 进入success状态时，执行打印成功的动作
      entry: (context) => console.log('请求成功：', context.data),
      on: { RESET: 'idle' }
    },
    error: {
      // 进入error状态时，执行打印错误的动作
      entry: (context) => console.error('请求失败：', context.error),
      on: {
        RETRY: 'loading', // 重试：直接回到loading，复用当前的fetchId
        RESET: {
          target: 'idle',
          actions: assign({ fetchId: null, data: null, error: null }) // 重置所有上下文
        }
      }
    }
  }
});

// 启动并订阅状态机
const advancedService = interpret(advancedFetchMachine);
advancedService.subscribe((state) => {
  console.log('当前状态：', state.value, '| 上下文：', state.context);
});
advancedService.start();

// 发送FETCH事件，携带fetchId=100
advancedService.send({ type: 'FETCH', fetchId: 100 });

// 模拟3秒后重置（可根据实际异步结果自动切换，无需手动）
// setTimeout(() => {
//   advancedService.send({ type: 'RESET' });
// }, 3000);
```

### 在react中使用

```js
import { createMachine, assign } from 'xstate';
import { useMachine } from '@xstate/react';
import { useState } from 'react';

// 1. 复用示例2的异步请求函数
const fetchData = async (id) => {
  await new Promise((resolve, reject) => {
    setTimeout(() => {
      Math.random() > 0.5 
        ? resolve({ id, data: `商品${id}的详情数据` }) 
        : reject(new Error('请求超时，请重试'));
    }, 1000);
  });
};

// 2. 创建状态机（与通用版一致，无React相关代码，状态逻辑与UI解耦）
const fetchMachine = createMachine({
  id: 'reactFetch',
  initial: 'idle',
  context: {
    goodsId: null,
    data: null,
    error: null
  },
  states: {
    idle: {
      on: {
        FETCH: {
          target: 'loading',
          actions: assign((_, event) => ({
            goodsId: event.goodsId,
            data: null,
            error: null
          }))
        }
      }
    },
    loading: {
      invoke: {
        src: (ctx) => fetchData(ctx.goodsId),
        onDone: {
          target: 'success',
          actions: assign((_, e) => ({ data: e.data }))
        },
        onError: {
          target: 'error',
          actions: assign((_, e) => ({ error: e.error.message }))
        }
      }
    },
    success: { on: { RESET: 'idle' } },
    error: { on: { RETRY: 'loading', RESET: 'idle' } }
  }
});

// 3. React组件
const XStateDemo = () => {
  // 输入框的本地状态（也可放到状态机上下文，简单状态可本地管理）
  const [inputId, setInputId] = useState('');

  // useMachine：传入状态机，返回[state, send]
  // state：当前状态对象（value=状态值，context=上下文）
  // send：发送事件的函数，替代通用版的service.send
  const [state, send] = useMachine(fetchMachine);

  // 解构状态和上下文，简化使用
  const { value: currentState, context } = state;
  const { data, error } = context;

  return (
    <div style={{ padding: '20px', maxWidth: '400px' }}>
      <h3>React + XState 状态管理示例</h3>
      <div style={{ margin: '10px 0' }}>
        <input
          type="text"
          placeholder="请输入商品ID"
          value={inputId}
          onChange={(e) => setInputId(e.target.value)}
          disabled={currentState === 'loading'}
          style={{ padding: '8px', width: '200px' }}
        />
        <button
          onClick={() => send({ type: 'FETCH', goodsId: inputId })}
          disabled={currentState === 'loading' || !inputId}
          style={{ marginLeft: '10px', padding: '8px 16px' }}
        >
          发起请求
        </button>
      </div>

      {/* 根据状态渲染UI */}
      {currentState === 'loading' && <div>加载中...</div>}
      {currentState === 'success' && (
        <div style={{ color: 'green', margin: '10px 0' }}>
          成功：{JSON.stringify(data)}
          <button
            onClick={() => send({ type: 'RESET' })}
            style={{ marginLeft: '10px' }}
          >
            重置
          </button>
        </div>
      )}
      {currentState === 'error' && (
        <div style={{ color: 'red', margin: '10px 0' }}>
          失败：{error}
          <button
            onClick={() => send({ type: 'RETRY' })}
            style={{ marginLeft: '10px' }}
          >
            重试
          </button>
          <button
            onClick={() => send({ type: 'RESET' })}
            style={{ marginLeft: '10px' }}
          >
            重置
          </button>
        </div>
      )}
    </div>
  );
};

export default XStateDemo;
```

### 条件执行

```js
idle: {
  on: {
    FETCH: [
      // 第一个过渡：带守卫，ID大于10时允许请求
      {
        target: 'loading',
        guard: (_, event) => Number(event.goodsId) > 10, // 守卫函数：返回布尔值
        actions: assign((_, event) => ({
          goodsId: event.goodsId,
          data: null,
          error: null
        }))
      },
      // 第二个过渡：默认过渡，ID不大于10时，触发错误提示（无状态切换）
      {
        actions: (_, event) => {
          alert(`商品ID${event.goodsId}不合法，必须大于10`);
        }
      }
    ]
  }
}
```

### 分层状态

```js
success: {
  initial: 'view', // 成功状态的初始子状态：展示
  states: {
    view: {
      on: { EDIT: 'edit' } // 展示 → 编辑
    },
    edit: {
      on: { SAVE: 'view', CANCEL: 'view' } // 编辑 → 展示
    }
  },
  on: { RESET: 'idle' } // 所有成功子状态都能触发RESET回到空闲
}
```