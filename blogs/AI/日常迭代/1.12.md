---
category: AI
date: 26.1.12
---

## AI 友好型文档

[ ] 是否有完整的 Props/Events/Slots 表格？

[ ] 是否包含了带有 import 的 完整代码示例？

[ ] 是否解释了 业务限制（什么时候该用，什么时候不该用）？

[ ] 是否导出了 TypeScript 类型定义？

[ ] 关键术语是否有 中英文对照？

## 一个业务组件，如何驱动两套 UI？

### 1. 不直接引用 UI 组件库， 接收一个 uiAdapter 参数。

适用：业务逻辑复杂，UI 需要多端适配。

| 维度     | 适配器模式方案                                           |
| -------- | -------------------------------------------------------- |
| 包体积   | 极好。用户只引入自己需要的适配器，不会打包另一套 UI 库。 |
| 扩展性   | 极强。如果要支持自研 UI 库，只需再写一个 Adapter。       |
| 开发成本 | 略高。每个组件都要写一套 Props 映射逻辑。                |
| 适用场景 | 需要跨团队、跨框架交付的重量级业务组件。                 |

#### 示例

比如我们有一个业务上传组件 `BusinessUpload`，它并不直接依赖 antd、MUI 等 UI 组件库，而是通过 `uiAdapter` 参数来实现与具体 UI 的解耦。

```ts
// 定义 UI Adapter 类型
interface UploadUIAdapter {
  (props: UploadUIProps): React.ReactNode;
}

// 业务层 props
interface BusinessUploadProps {
  action: string;
  uiAdapter: UploadUIAdapter;
}

// 模拟 UI 需要的 props
interface UploadUIProps {
  onChange: (files: FileList) => void;
  multiple?: boolean;
}

// 业务上传组件
const BusinessUpload: React.FC<BusinessUploadProps> = ({
  action,
  uiAdapter,
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // ...业务逻辑，比如校验、上传等
    const files = e.target.files;
    if (files) {
      // ...上传前业务处理
      console.log("上传文件", files);
    }
  };

  // 传递给 UI 组件的 props
  const uploadProps: UploadUIProps = {
    onChange: handleChange,
    multiple: true,
  };

  return <>{uiAdapter(uploadProps)}</>;
};

// 例如分别绑定 antd Upload、MUI Button 作为 uiAdapter
import { Upload as AntdUpload } from "antd";
import Button from "@mui/material/Button";

const antdAdapter: UploadUIAdapter = (uploadProps) => (
  <AntdUpload {...uploadProps} />
);

const muiAdapter: UploadUIAdapter = (uploadProps) => (
  <Button component="label">
    上传 <input type="file" style={{ display: "none" }} {...uploadProps} />
  </Button>
);

// 使用业务组件时注入适配器
<BusinessUpload action="/api/upload" uiAdapter={antdAdapter} />;
<BusinessUpload action="/api/upload" uiAdapter={muiAdapter} />;
```

AI 友好原因

1. **职责分离**：当你要求 AI 增加一个业务逻辑（如“上传前压缩图片”）时，它只需要修改 BusinessUpload，而不会意外破坏 antd 或 MUI 的样式代码。

2. **契约明确**：AI 只要看到 UploadUIProps 接口，就能立刻明白业务层和 UI 层的数据交换方式。

3. **可测试性**：你可以让 AI 快速生成针对业务逻辑的单元测试，而不必挂载复杂的 UI 环境。

### 2. Headless UI 模式

编写一个 useUpload 的 Custom Hook 来处理所有业务逻辑（上传进度、格式拦截、Token 获取），而 UI 部分完全交给用户或子组件。

优点：业务逻辑与 UI 库 100% 解耦，不仅支持 antd/MUI，未来甚至支持原生 HTML。

AI 友好度：极高。AI 只需要理解逻辑 Hook 的输入输出，UI 层可以随意切换

```ts
// 业务逻辑 Hooks
const { getProps, files } = useBusinessUpload({ action: '/api/upload' });

// 配合 antd 使用
<AntdUpload {...getProps()} />

// 配合 MUI 使用
<MuiButton component="label">
  上传 <input {...getProps()} hidden type="file" />
</MuiButton>
```

### 如何选择？

- 如果你的**业务组件需要高度复用、跨端交付**，或者将来可能支持多套 UI/主题、甚至外部团队也会用，推荐采用「适配器模式」。虽然初期开发成本略高，但长期收益大，维护和扩展更安心。
- 如果你更关注**极致解耦、最小依赖**，或者 UI 变化频繁、业务轻量，可以优先考虑「Headless UI 模式」。这样既不会被 UI 框架锁死，也方便 AI 或新接手的同事只关注核心逻辑。
- 当然，实际项目中这两种方案可以结合使用：例如业务逻辑由通用 hooks 提供（Headless），UI 适配通过参数注入（Adapter），取长补短。

**一图总结：**

| 场景        | 推荐方案    |
| ----------- | ----------- |
| 跨团队交付  | 适配器模式  |
| 跨端适配    | 适配器模式  |
| 业务轻量    | Headless UI |
| UI 频繁变化 | Headless UI |
| 业务重逻辑  | 适配器模式  |

尽量用适配器模式， 业务组件内部进行组装。

示例使用： `“使用 BusinessUpload 组件，设置 adapter 为 antd/mtd。”`
